#!/bin/bash

# 内置关键字 [[]]
# *[[]] 和 test 比较中， test 能做到的， [[]] 也能做到，而且 [[]] 做的更好；test 做不到的 [[]] 还能做到。可以认为 [[]] 是 test 的升级版，对细节进行了优化，并且扩展了一些功能。
# 语法： [[ expression ]]
# 语法释义：当 [[]] 判断 expression 成立时，退出状态为 0，否则为非 0 值。
# 语法注意：[[]] 内部和 expression 之间的空格，这两个空格是必须的，否则会导致语法错误。
# 注意： [[]] 是 Shell 内置关键字，不是命令【在使用时没有给函数传递参数的过程】，所以 test 命令的某些注意事项在 [[]] 中就不存在了，具体包括：
# 不需要把变量名用双引号 "" 包围起来，即使变量是空值，也不会报错。
# 不需要也不能对 > 、 < 进行转译，转以后会报错。

# 使用 [[]] 进行条件运算
read str1
read str2
if [[ -z $str1 ]] || [[ -z $str2 ]] # 不需要对变量加双引号【 -z 用来判断字符串是否为空】
then
  echo "str1 和 str2 不能为空"
elif [[ $str1 < $str2 ]]
then
  echo "str1 小于 str2"
else
  echo "str1 大于等于 str2"
fi

# 使用 [[]] 进行逻辑运算
# *对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来。
# 注意1： [[]]剔除了 test 命令的 -o 和 -a 选项，所以只能使用 || 和 &&。
# 注意2：如果写成 [[ -z $str1 -o -z $str2 ]] 会报错。
read str3
read str4
read str5
read str6
if [[ -z $str3 ]] || [[ -z $str4 ]]; then
  echo "str3 和 str4 不能为空"
elif [[ -z $str5 || -z $str6 ]]; then
  echo "str5 和 str6 不能为空"
else
  echo "str3 、 str4 、 str5 、 str6 都不为空"
fi

# 在 [[]] 里面使用正则表达式
# 语法： [[ str=~regex ]]
# 语法释义： str 表示字符串， regex 表示正则表达式。
# *有了 [[]] ，你还有什么理由使用 test 或者 [] ， [[]] 完全可以替代之，而且更加方便，更加强大。
read telphone
if [[ $telphone=~^1[0-9]{10}$ ]]; then # “^1[0-9]{10}$”的说明： ^ 匹配字符串的开头（一个位置）； [0-9]{10} 匹配连续的十个数字； $ 匹配字符串的末尾（一个位置）。
  echo "输入的是手机号码"
else
  echo "输入的不是手机号码"
fi