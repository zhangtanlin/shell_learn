#!/bin/bash

# 退出状态
# 每一条 Shell 命令，不管是 Bash 内置命令（例如 cd、echo），还是外部的 Linux 命令（例如 ls、awk），还是自定义的 Shell 函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的退出状态（exit statu）。
# *很多 Linux 命令其实是一个 C 语言程序，例如 c 语言中的 main() 函数最后都有一个return 0 ，如果程序想在中间退出，还可以使用 exit 0 ，这就是 C 语言程序的退出状态。当有其它程序调用这个程序时，就可以捕获这个退出状态。
# * if 语句的判断条件，从本质上讲，判断的就是命令的退出状态。
# *按照惯例来说，退出状态为 0 表示“成功”【可以理解为是否失败】；也就是说程序执行完成并且没有遇到任何问题。除 0 以外的其它任何退出状态都为“失败”。

# 使用 $? 获取命令的退出状态
read a
read b
(( $a == $b ))
echo "退出状态为：$?"

# if 语句的一个神奇之处是允许我们使用逻辑运算符将多个退出状态组合起来，这样就可以一次判断多个条件了
# 退出状态和逻辑运算符的组合：
# &&        expression1 && expression2        逻辑非运算符“&&”，当 expression1 和 expression2 同时成立时，整个表达式才成立。
#                                             如果检测到 expression1 的退出状态为 0 ，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。
# ||        expression1 || expression2	      逻辑非运算符“||”，当 expression1 和 expression2 两个表达式中只要有一个成立，整个表达式就成立。
#                                             如果检测到 expression1 的退出状态为 1，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。
# !         !expression	                      逻辑非运算符“!”，相当于“取反”的效果。如果 expression 成立，那么整个表达式就不成立；如果 expression 不成立，那么整个表达式就成立。

# 将用户输入的 URL 写入到文件中：
# * test 是 Shell 内置命令，可以对文件或者字符串进行检测，其中， -w 选项用来检测文件是否存在并且可写， -n 选项用来检测字符串是否非空。
# * > 表示重定向，默认情况下， echo 向控制台输出，这里我们将输出结果重定向到文件。
read filename # 因为当前目录已存在“测试文件【写入文字】.txt”，所以输入时候尽量输入这个文件夹【不用添加 ./ 】。
read url
if test -w $filename && test -n $url      # test -w 表示文件存在且可以写入则为真， test -n 表示字符串的长度不为零则为真
then
  echo $url > $filename                   # 把文字写入文件内【是一个内置方法】
  echo "把url：“$url”，写入到 “$filename”" # 输出提示
else
  echo "写入失败"
fi

